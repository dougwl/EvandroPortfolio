"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@swc/core");
const commander_1 = __importDefault(require("commander"));
const glob_1 = __importDefault(require("glob"));
const uniq_1 = __importDefault(require("lodash/uniq"));
const package_json_1 = __importDefault(require("../../package.json"));
// Standard swc input configs.
commander_1.default.option("-f, --filename [filename]", "filename to use when reading from stdin - this will be used in source-maps, errors etc");
commander_1.default.option("--config-file [path]", "Path to a .swcrc file to use");
commander_1.default.option("--env-name [name]", "The name of the 'env' to use when loading configs and plugins. " +
    "Defaults to the value of SWC_ENV, or else NODE_ENV, or else 'development'.");
// commander.option(
//     "--typescript",
//     "Treat input as typescript",
// );
// Basic file input configuration.
commander_1.default.option("--no-swcrc", "Whether or not to look up .swcrc files");
commander_1.default.option("--ignore [list]", "list of glob paths to **not** compile", collect);
commander_1.default.option("--only [list]", "list of glob paths to **only** compile", collect);
commander_1.default.option("-w, --watch", "Recompile files on changes");
commander_1.default.option("-q, --quiet", "Suppress compilation output");
// General source map formatting.
commander_1.default.option("-s, --source-maps [true|false|inline|both]", "", booleanify);
commander_1.default.option("--source-map-target [string]", "set `file` on returned source map");
commander_1.default.option("--source-file-name [string]", "set `sources[0]` on returned source map");
commander_1.default.option("--source-root [filename]", "the root from which all sources are relative");
commander_1.default.option("-o, --out-file [out]", "Compile all input files into a single file");
commander_1.default.option("-d, --out-dir [out]", "Compile an input directory of modules into an output directory");
commander_1.default.option("-D, --copy-files", "When compiling a directory copy over non-compilable files");
commander_1.default.option("--include-dotfiles", "Include dotfiles when compiling and copying non-compilable files");
commander_1.default.option("-C, --config <config>", "Override a config from .swcrc file. e.g. -C module.type=amd -C module.moduleId=hello", collect);
commander_1.default.option("--sync", "Invoke swc synchronously. Useful for debugging.", collect);
commander_1.default.version(`@swc/cli: ${package_json_1.default.version}
@swc/core: ${core_1.version}`);
commander_1.default.usage("[options] <files ...>");
function booleanify(val) {
    if (val === "true" || val == 1) {
        return true;
    }
    if (val === "false" || val == 0 || !val) {
        return false;
    }
    return val;
}
function collect(value, previousValue) {
    // If the user passed the option with no value, like "babel file.js --presets", do nothing.
    if (typeof value !== "string")
        return previousValue;
    const values = value.split(",");
    return previousValue ? previousValue.concat(values) : values;
}
function parserArgs(args) {
    //
    commander_1.default.parse(args);
    const errors = [];
    let filenames = commander_1.default.args.reduce(function (globbed, input) {
        let files = glob_1.default.sync(input);
        if (!files.length)
            files = [input];
        return globbed.concat(files);
    }, []);
    filenames = uniq_1.default(filenames);
    if (commander_1.default.outDir && !filenames.length) {
        errors.push("--out-dir requires filenames");
    }
    if (commander_1.default.outFile && commander_1.default.outDir) {
        errors.push("--out-file and --out-dir cannot be used together");
    }
    if (commander_1.default.watch) {
        if (!commander_1.default.outFile && !commander_1.default.outDir) {
            errors.push("--watch requires --out-file or --out-dir");
        }
        if (!filenames.length) {
            errors.push("--watch requires filenames");
        }
    }
    if (!commander_1.default.outDir &&
        filenames.length === 0 &&
        typeof commander_1.default.filename !== "string" &&
        commander_1.default.swcrc !== false) {
        errors.push("stdin compilation requires either -f/--filename [filename] or --no-swcrc");
    }
    if (errors.length) {
        console.error("swc:");
        errors.forEach(function (e) {
            console.error("  " + e);
        });
        process.exit(2);
    }
    const opts = commander_1.default.opts();
    let swcOptions = {
        jsc: {
            parser: undefined,
            transform: {}
        },
        // filename,
        sourceMaps: opts.sourceMaps,
        configFile: opts.configFile
    };
    if (opts.config) {
        for (const cfg of opts.config) {
            const i = cfg.indexOf("=");
            let key, value;
            if (i === -1) {
                key = cfg;
                value = true;
            }
            else {
                key = cfg.substring(0, i);
                value = cfg.substring(i + 1);
            }
            let obj = swcOptions;
            const ks = key.split(".");
            for (const k of ks.slice(0, ks.length - 1)) {
                if (!obj[k]) {
                    obj[k] = {};
                }
                obj = obj[k];
            }
            obj[ks[ks.length - 1]] = value;
        }
    }
    let cliOptions = {
        outDir: opts.outDir,
        outFile: opts.outFile,
        filename: opts.filename,
        filenames,
        sync: !!opts.sync,
        sourceMapTarget: opts.sourceMapTarget,
        extensions: opts.extensions,
        keepFileExtension: opts.keepFileExtension,
        verbose: !!opts.verbose,
        watch: !!opts.watch,
        relative: !!opts.relative,
        copyFiles: !!opts.copyFiles,
        includeDotfiles: !!opts.includeDotfiles,
        deleteDirOnStart: !!opts.deleteDirOnStart,
        quiet: !!opts.quiet
    };
    return {
        swcOptions,
        cliOptions
    };
}
exports.default = parserArgs;
