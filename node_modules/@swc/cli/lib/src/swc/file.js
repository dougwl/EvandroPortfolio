"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_source_map_1 = __importDefault(require("convert-source-map"));
const fs_1 = __importDefault(require("fs"));
const defaults_1 = __importDefault(require("lodash/defaults"));
const path_1 = __importDefault(require("path"));
const slash_1 = __importDefault(require("slash"));
const source_map_1 = __importDefault(require("source-map"));
const util = __importStar(require("./util"));
// @ts-ignore
function default_1({ cliOptions, swcOptions }) {
    return __awaiter(this, void 0, void 0, function* () {
        function buildResult(fileResults) {
            return __awaiter(this, void 0, void 0, function* () {
                const map = new source_map_1.default.SourceMapGenerator({
                    file: cliOptions.sourceMapTarget ||
                        path_1.default.basename(cliOptions.outFile || "") ||
                        "stdout",
                    sourceRoot: swcOptions.sourceRoot
                });
                let code = "";
                let offset = 0;
                for (const result of fileResults) {
                    if (!result)
                        continue;
                    code += result.code + "\n";
                    if (result.map) {
                        const consumer = yield new source_map_1.default.SourceMapConsumer(result.map);
                        const sources = new Set();
                        consumer.eachMapping(function (mapping) {
                            if (mapping.source != null)
                                sources.add(mapping.source);
                            map.addMapping({
                                generated: {
                                    line: mapping.generatedLine + offset,
                                    column: mapping.generatedColumn
                                },
                                source: mapping.source,
                                // @ts-ignore
                                original: mapping.source == null
                                    ? null
                                    : {
                                        line: mapping.originalLine,
                                        column: mapping.originalColumn
                                    }
                            });
                        });
                        sources.forEach(source => {
                            const content = consumer.sourceContentFor(source, true);
                            if (content !== null) {
                                map.setSourceContent(source, content);
                            }
                        });
                        offset = code.split("\n").length - 1;
                    }
                }
                // add the inline sourcemap comment if we've either explicitly asked for inline source
                // maps, or we've requested them without any output file
                if (swcOptions.sourceMaps === "inline" ||
                    (!cliOptions.outFile && swcOptions.sourceMaps)) {
                    code += "\n" + convert_source_map_1.default.fromObject(map).toComment();
                }
                return {
                    map: map,
                    code: code
                };
            });
        }
        function output(fileResults) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield buildResult(fileResults);
                if (cliOptions.outFile) {
                    // we've requested for a sourcemap to be written to disk
                    if (swcOptions.sourceMaps && swcOptions.sourceMaps !== "inline") {
                        const mapLoc = cliOptions.outFile + ".map";
                        result.code = util.addSourceMappingUrl(result.code, mapLoc);
                        fs_1.default.writeFileSync(mapLoc, JSON.stringify(result.map));
                    }
                    fs_1.default.writeFileSync(cliOptions.outFile, result.code);
                }
                else {
                    process.stdout.write(result.code + "\n");
                }
            });
        }
        function readStdin() {
            return new Promise((resolve, reject) => {
                let code = "";
                process.stdin.setEncoding("utf8");
                process.stdin.on("readable", function () {
                    const chunk = process.stdin.read();
                    if (chunk !== null)
                        code += chunk;
                });
                process.stdin.on("end", function () {
                    resolve(code);
                });
                process.stdin.on("error", reject);
            });
        }
        function stdin() {
            return __awaiter(this, void 0, void 0, function* () {
                const code = yield readStdin();
                const res = yield util.transform(cliOptions.filename, code, defaults_1.default({
                    sourceFileName: "stdin"
                }, swcOptions), cliOptions.sync);
                output([res]);
            });
        }
        function walk(filenames) {
            return __awaiter(this, void 0, void 0, function* () {
                const _filenames = [];
                filenames.forEach(function (filename) {
                    if (!fs_1.default.existsSync(filename))
                        return;
                    const stat = fs_1.default.statSync(filename);
                    if (stat.isDirectory()) {
                        const dirname = filename;
                        util
                            .readdirForCompilable(filename, cliOptions.includeDotfiles, cliOptions.extensions)
                            .forEach(function (filename) {
                            _filenames.push(path_1.default.join(dirname, filename));
                        });
                    }
                    else {
                        _filenames.push(filename);
                    }
                });
                const results = yield Promise.all(_filenames.map(function (filename) {
                    return __awaiter(this, void 0, void 0, function* () {
                        let sourceFilename = filename;
                        if (cliOptions.outFile) {
                            sourceFilename = path_1.default.relative(path_1.default.dirname(cliOptions.outFile), sourceFilename);
                        }
                        sourceFilename = slash_1.default(sourceFilename);
                        try {
                            return yield util.compile(filename, defaults_1.default({
                                sourceFileName: sourceFilename,
                                // Since we're compiling everything to be merged together,
                                // "inline" applies to the final output file, but to the individual
                                // files being concatenated.
                                sourceMaps: swcOptions.sourceMaps === "inline"
                                    ? true
                                    : swcOptions.sourceMaps
                            }, swcOptions), cliOptions.sync);
                        }
                        catch (err) {
                            if (!cliOptions.watch) {
                                throw err;
                            }
                            console.error(err);
                            return null;
                        }
                    });
                }));
                output(results);
            });
        }
        function files(filenames) {
            return __awaiter(this, void 0, void 0, function* () {
                yield walk(filenames);
                if (cliOptions.watch) {
                    const chokidar = util.requireChokidar();
                    chokidar
                        .watch(filenames, {
                        persistent: true,
                        ignoreInitial: true,
                        awaitWriteFinish: {
                            stabilityThreshold: 50,
                            pollInterval: 10
                        }
                    })
                        .on("all", function (type, filename) {
                        if (!util.isCompilableExtension(filename, cliOptions.extensions)) {
                            return;
                        }
                        if (type === "add" || type === "change") {
                            if (cliOptions.verbose) {
                                console.log(type + " " + filename);
                            }
                            walk(filenames).catch(err => {
                                console.error(err);
                            });
                        }
                    });
                }
            });
        }
        if (cliOptions.filenames.length) {
            yield files(cliOptions.filenames);
        }
        else {
            yield stdin();
        }
    });
}
exports.default = default_1;
